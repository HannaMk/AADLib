--------------------------------------------------------------------------------
-- Check whether the threads bound to each processors can be
-- schedduled with RMA (cf. Liu, Layland. "Scheduling Algorithms for
-- Multi-programming in hard-Real-Time Environment", JACM, 01/1973)

-- Earliest deadline first (EDF) is a dynamic scheduling 
-- algorithm used in real-time operating systems 

-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------

theorem check_scheduling

-- This theorems check rma and edf schedulability hypothesis

foreach e in local_set do
	var t := 1 ;
	requires(	
				required_properties and 
				shared_data and 
				check_priority_rma
				and scheduling);
				
	check (1 <> 2);
end check_scheduling;

-------------------------------------------------------------------------

theorem required_properties

foreach e in thread_set do

check(  Exists (e,"Dispatch_Protocol")
	and (Property (e, "Dispatch_Protocol") = "Periodic")
	and Exists (e,"compute_execution_time")
   	and Exists (e,"Period")
   	and (Last (Property (e,"compute_execution_time")) <= Property (e, "Period"))
   	and (Property (e, "Period") = Property (e, "deadline")) );

end required_properties;

-------------------------------------------------------------------------

theorem shared_data

foreach e in data_set do

accessor_connections := { x in connection_set | Is_Accessed_By (e,x) };
accessor_threads := {t in thread_set |  Is_Accessed_By (t,accessor_connections)};
processes := { p in Process_Set | Is_Subcomponent_Of (accessor_threads, p ) } ;
threads_processors := {p in processor_set | Is_Bound_to ( processes, p) };

var protocol := Property (threads_processors, "Scheduling_protocol");
var supported_pcp := list("rms");

var tmp := cardinal (accessor_threads);

check(	if (cardinal (accessor_threads) <= 1)
		then (1=1)
		
			-- check PCP applicability
		else (	if (Is_In (protocol , supported_pcp) )
					and (Property (e, "priority") >=  Max (Property (accessor_threads, "priority")) )
				then (1=1) 
				else (1<>1) )
	);

end shared_data;

-------------------------------------------------------------------------

theorem check_priority_rma

foreach e in thread_set do 

var priority := Property (e, "priority");

high_priority := {t in Thread_Set | Property (t, "priority") > priority};
Equal_priority := {t in Thread_Set | Property (t, "priority") = priority};

var period := Property (e, "Period");

high_periods_high := { t in high_priority | Property (t, "period") > period}; 
high_periods_low := { t in high_priority | Property (t, "period") < period}; 

Processors := {x in processor_set | (Exists (x,"Processor_properties::Max_Prio_First")  
										and Exists (x,"scheduling_protocol") )};

var rms_protocol := list ("RMS");

var MPF_high := List ("high");
var MPF_low := List ("low");
			 
check ( if ( cardinal (processor_set) = 1
			and Is_In (rms_protocol, Property (Processors, "scheduling_protocol"))
			and (cardinal (Equal_priority) = 1)
			)
			
			then ( if (Is_In (MPF_high, Property (Processors, "Processor_properties::Max_Prio_First")))
					then (cardinal (high_periods_high) = 0) 
					else (cardinal (high_periods_low) = 0) )
					
		else (1<>1));

end check_priority_rma;
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------

-- Utilization_Factor : compute and return utilization factor
-- of a thread set.

theorem Utilization_Factor

foreach e in Local_Set do

var Period 	:= Property (e, "period");
var CET		:= Last ( Property (e, "compute_execution_time"));
var Factor	:= CET / Period;

return (MSum (Factor));

end Utilization_Factor;

-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------

-- Scheduling theorem is designed for checking EDF and RMA schedulability

theorem scheduling
foreach e in processor_set do 

Processes(e) := { x in process_set | Is_Bound_To (x,e)};
threads	:= {x in thread_set | Is_Subcomponent_Of (x, processes)};
var U := Compute Utilization_Factor(Threads);

var get_protocol := Property(e,"Scheduling_Protocol");

var rms_protocol := list ("RMS");
var edf_protocol := list ("EDF");

var bool_RMS := if (is_in (rms_protocol, get_protocol)) then 1 else 0;
var bool_EDF := if (is_in (edf_protocol, get_protocol)) then 1 else 0;
var single_protocol := if ( (bool_RMS + bool_EDF) <> 1 ) then 0 else (bool_RMS + bool_EDF);

 check (if (bool_RMS * single_protocol = 1)
 		then (U <= (Cardinal (Threads) * (2 ** (1 / Cardinal (Threads))) -1)) 	-- Check RMA
 		else (if ( bool_EDF * single_protocol = 1)							
 		then (U <= 1 * bool_EDF * single_protocol)		-- Check EDF
 		else (1 < 0) ) ); 		-- Return FALSE
 		
 end scheduling;
 
 -------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------

